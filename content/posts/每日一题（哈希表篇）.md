---
title: 每日一题（哈希表篇）
date: 2024-11-16
lastmod: 2024-11-16
tags:
  - 持续更新
  - C++
  - 哈希表
  - 力扣原题
categories:
  - 编程
  - 算法
image: /image/每日一题/每日一题(哈希表篇).jpg
top: true
hideFromHomePage: false
share: true
draft: false
---
# 简单题

## 202. 快乐数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/happy-number/description/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

- **输入：** n = 19
- **输出：** true
- **解释：**
  12 + 92 = 82
  82 + 22 = 68
  62 + 82 = 100
  12 + 02 + 02 = 1

**示例 2：**

- **输入：** n = 2
- **输出：** false

**提示：**

- 1 <= n <= 2<sup>31</sup> - 1

### 参考代码

```cpp
    bool isHappy(int n)
    {
        int sum = 0, digit = 0;                  // 初始化 sum 为 0，digit 为 0
        unordered_map<int, bool> map{{n, true}}; // 创建一个哈希表，记录已出现的和
        while (true) // 无限循环，直到找到结果
        {
            digit = n % 10;       // 取出当前数字的最后一位
            n /= 10;              // 去掉最后一位数字
            sum += digit * digit; // 计算当前数字的平方并累加到 sum
            if (n == 0) // 如果 n 变为 0，说明已经处理完所有位
            {
                if (sum == 1) // 如果当前和为 1，n 是快乐数
                    break;
                if (map[sum] == true) // 如果当前和已经出现过，n 不是快乐数
                    return false;
                map[sum] = true; // 将当前和加入哈希表
                n = sum;         // 将和作为新的 n 继续处理
                sum = 0;         // 重置 sum 为 0，准备下一轮计算
            }
        }
        return true; // 如果循环结束，说明 n 是快乐数
    }
```

#### 算法步骤

1. **初始化**：
	- 创建一个变量 `sum` 用于保存每次计算的平方和，初始为 0。
	- 创建一个变量 `digit` 用于保存提取的每位数字，初始为 0。
	- 使用哈希表 `map` 来记录已经出现过的平方和，初始化时将输入 `n` 加入。

2. **循环处理**：
	- 使用 `while (true)` 无限循环，直到找到结果（快乐数或确定不是快乐数）。
	- 在循环内，提取 `n` 的最后一位数字，并更新 `n` 去掉最后一位。
	- 计算当前数字的平方并累加到 `sum`。

3. **条件判断**：
	- 如果 `n` 变为 0，表示已经处理完所有位：
		- 检查 `sum` 是否为 1，是则退出循环，返回 `true`。
		- 如果当前的 `sum` 已经在哈希表中出现过，说明进入循环，返回 `false`。
		- 否则，将当前 `sum` 记录进哈希表，并将 `sum` 作为新的 `n` 继续处理，同时重置 `sum`。

4. **结束条件**：
	- 如果循环结束，说明 `n` 到达 1，返回 `true`。

#### 注意点

- **循环检测**：使用哈希表来记录已经出现过的平方和，有效避免无限循环。
- **重置和更新**：在每次计算平方和后，将其作为新的 `n` 处理，并重置 `sum`，确保每轮计算的独立性。

---

---
# 中等题
## 204. 计数质数

[力扣原题链接 (中等题)](https://leetcode.cn/problems/count-primes/description/)

给定整数 `n` ，返回 _所有小于非负整数 `n` 的质数的数量_ 。

**示例 1：**

- **输入：** n = 10
- **输出：** 4
- **解释：** 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

**示例 2：**

- **输入：** n = 0
- **输出：** 0

**示例 3：**

- **输入：** n = 1
- **输出：** 0

**提示：**

- 0 <= `n` <= 5 * 10<sup>6</sup>

### 参考代码

```
    int countPrimes(int n)
    {
        // 如果 n 为 0 或 1，直接返回 0
        if (n == 0 || n == 1)
            return 0;
        // 初始化一个布尔类型的向量，用于标记质数
        vector<bool> nums(n, true);
        int times = 1, temp = 0;
        // 使用埃拉托斯特尼筛法标记非质数
        for (int i = 2; i <= nums.size() / 2; ++i)
        {
            if (nums[i] == true)
            {
                times = 2;
                temp = i * times;
                while (temp <= n - 1)
                {
                    nums[temp] = false;
                    temp = i * ++times;
                }
            }
        }
        // 统计质数的数量
        int count = 0;
        for (const auto &num : nums)
        {
            if (num == true)
                ++count;
        }
        // 返回质数的数量，减去 0 和 1 这两个非质数
        return count - 2;
    }
```

#### 主要步骤

1. **边界条件处理**：
	- 如果 `n` 为 0 或 1，直接返回 0，因为 0 和 1 都不是质数。

2. **初始化布尔向量**：
	- 使用 `vector<bool> nums(n, true)` 初始化一个布尔类型的向量，长度为 `n`，所有元素初始值为 `true`，表示默认所有数都是质数。

3. **埃拉托斯特尼筛法**：
	- 从 2 开始，遍历到 `n/2`，对于每个质数 `i`，将其倍数标记为非质数（即 `false`）。
	- 具体实现是通过一个 `while` 循环，不断将 `i` 的倍数标记为 `false`，直到倍数超过 `n-1`。

4. **统计质数数量**：
	- 遍历布尔向量 `nums`，统计值为 `true` 的元素数量。
	- 由于 0 和 1 不是质数，最终结果需要减去 2。

5. **返回结果**：
	- 返回统计的质数数量。

#### 注意点

- **边界条件**：函数一开始就处理了 `n` 为 0 或 1 的情况，避免了后续不必要的计算。

- **布尔向量的初始化**：使用 `vector<bool>` 来标记质数和非质数，初始值为 `true`，表示默认所有数都是质数。

-  **埃拉托斯特尼筛法的实现**：遍历范围是从 2 到 `n/2`，因为大于 `n/2` 的数不可能再有倍数小于 `n`。使用 `while` 循环来标记非质数，确保所有倍数都被正确标记。

- **统计质数数量**：在统计质数数量时，需要减去 0 和 1 这两个非质数。
---
title: 每日一题（哈希表篇）
date: 2024-11-16
lastmod: 2024-11-22
tags:
  - 持续更新
  - C++
  - 哈希表
  - 力扣原题
categories:
  - 编程
  - 算法
image: /image/每日一题/每日一题(哈希表篇).jpg
top: true
hideFromHomePage: false
share: true
draft: false
---

# 简单题

## 202. 快乐数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/happy-number/description/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

- **输入：** n = 19
- **输出：** true
- **解释：**
  12 + 92 = 82
  82 + 22 = 68
  62 + 82 = 100
  12 + 02 + 02 = 1

**示例 2：**

- **输入：** n = 2
- **输出：** false

**提示：**

- 1 <= n <= 2<sup>31</sup> - 1

### 参考代码

```cpp
    bool isHappy(int n)
    {
        int sum = 0, digit = 0;                  // 初始化 sum 为 0，digit 为 0
        unordered_map<int, bool> map{{n, true}}; // 创建一个哈希表，记录已出现的和
        while (true) // 无限循环，直到找到结果
        {
            digit = n % 10;       // 取出当前数字的最后一位
            n /= 10;              // 去掉最后一位数字
            sum += digit * digit; // 计算当前数字的平方并累加到 sum
            if (n == 0) // 如果 n 变为 0，说明已经处理完所有位
            {
                if (sum == 1) // 如果当前和为 1，n 是快乐数
                    break;
                if (map[sum] == true) // 如果当前和已经出现过，n 不是快乐数
                    return false;
                map[sum] = true; // 将当前和加入哈希表
                n = sum;         // 将和作为新的 n 继续处理
                sum = 0;         // 重置 sum 为 0，准备下一轮计算
            }
        }
        return true; // 如果循环结束，说明 n 是快乐数
    }
```

#### 算法步骤

1. **初始化**：
	- 创建一个变量 `sum` 用于保存每次计算的平方和，初始为 0。
	- 创建一个变量 `digit` 用于保存提取的每位数字，初始为 0。
	- 使用哈希表 `map` 来记录已经出现过的平方和，初始化时将输入 `n` 加入。

2. **循环处理**：
	- 使用 `while (true)` 无限循环，直到找到结果（快乐数或确定不是快乐数）。
	- 在循环内，提取 `n` 的最后一位数字，并更新 `n` 去掉最后一位。
	- 计算当前数字的平方并累加到 `sum`。

3. **条件判断**：
	- 如果 `n` 变为 0，表示已经处理完所有位：
		- 检查 `sum` 是否为 1，是则退出循环，返回 `true`。
		- 如果当前的 `sum` 已经在哈希表中出现过，说明进入循环，返回 `false`。
		- 否则，将当前 `sum` 记录进哈希表，并将 `sum` 作为新的 `n` 继续处理，同时重置 `sum`。

4. **结束条件**：
	- 如果循环结束，说明 `n` 到达 1，返回 `true`。

#### 注意点

- **循环检测**：使用哈希表来记录已经出现过的平方和，有效避免无限循环。
- **重置和更新**：在每次计算平方和后，将其作为新的 `n` 处理，并重置 `sum`，确保每轮计算的独立性。

---

## 205. 同构字符串

[力扣原题链接 (简单题)](https://leetcode.cn/problems/isomorphic-strings/description/)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

- **输入：** s = "egg", t = "add"
- **输出：** true

**示例 2：**

- **输入：** s = "foo", t = "bar"
- **输出：** false

**示例 3：**

- **输入：** s = "paper", t = "title"
- **输出：** true

**提示：**

- 1 <= `s.length` <= 5 * 10<sup>4</sup>
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

### 参考代码

```cpp
    bool isIsomorphic(string s, string t)
    {
        // 定义一个映射关系，用于存储字符从 s 到 t 的映射
        unordered_map<char, char> map;
        // 遍历字符串 s
        for (int i = 0; i < s.length(); ++i)
        {
            // 如果 s[i] 尚未在 map 中，添加映射关系
            if (map.find(s[i]) == map.end())
                map[s[i]] = t[i];
            else
            {
                // 如果已经存在映射，检查映射是否一致
                if (map[s[i]] != t[i])
                    return false; // 如果不一致，则字符串不构
            }
        }
        // 定义一个反向映射关系，用于检查 t 到 s 的唯一性
        unordered_map<char, char> reversedMap;
        // 遍历前面的映射关系
        for (const auto &p : map)
        {
            // 如果 p.second 尚未在 reversedMap 中，添加反向映射关系
            if (reversedMap.find(p.second) == reversedMap.end())
                reversedMap[p.second] = p.first;
            else
            {
                // 如果已经存在反向映射，检查反向映射是否一致
                if (reversedMap[p.second] != p.first)
                    return false; // 如果不一致，则字符串不构
            }
        }
        return true; // 如果所有检查通过，则字符串同构
    }
```

#### 主要步骤

1. **建立映射关系**：使用一个哈希表 `map` 来存储从字符串 `s` 到 `t` 的映射关系。

2. **遍历字符串**：使用循环逐个检查 `s` 中的字符：
	- 如果字符还没有在映射中，添加字符 `s[i]` 的映射关系到 `t[i]`。
	- 如果已经存在映射关系，检查当前字符的映射是否一致。

3. **反向映射检查**：为了确保不同的字符不会映射到相同的字符，使用另一个哈希表 `reversedMap` 检查从 `t` 到 `s` 的反向映射关系。

4. **返回结果**：如果所有的映射关系都通过了检查，则返回 `true`；否则返回 `false`。

#### 注意点

- **唯一性**：同构的要求包括相同字符必须映射为相同字符，不同字符不能映射为相同字符。这两个条件的检查都必须通过，才能判定两个字符串是同构的。

---

## 290. 单词规律

[力扣原题链接 (简单题)](https://leetcode.cn/problems/word-pattern/description/)

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

- **输入:** pattern = "abba", s = "dog cat cat dog"
- **输出:** true

**示例 2:**

- **输入:** pattern = "abba", s = "dog cat cat fish"
- **输出:** false

**示例 3:**

- **输入:** pattern = "aaaa", s = "dog cat cat dog"
- **输出:** false

**提示:**

- 1 <= `pattern.length` <= 300
- `pattern` 只包含小写英文字母
- 1 <= `s.length` <= 3000
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随对空格
- `s` 中每个单词都被 **单个空格** 分隔

### 参考代码

```cpp
    bool wordPattern(string pattern, string s)
    {
        istringstream is(s);             // 使用字符串流分隔字符串 s 中的单词
        string word;                     // 存储当前读取的单词
        int i = 0;                       // pattern 的索引，同时统计单词数量
        unordered_map<string, char> map; // 用于存放单词到字母的映射
        // 逐个读取单词并与 pattern 进行比对
        while (is >> word)
        {
            if (map.find(word) == map.end()) // 如果单词不在映射中
                map[word] = pattern[i++];    // 将单词与对应的字母建立映射
            else
            {
                if (map[word] != pattern[i++]) // 如果单词已经存在映射但与当前输出的字母不同
                    return false;              // 返回 false，表示不符合规律
            }
        }
        // 如果读取的单词数与 pattern 中的字母数不一致，返回 false
        if (i != pattern.length())
            return false;
        unordered_map<char, string> reversedMap; // 用于存放字母到单词的反向映射
        // 检查反向映射是否符合规律
        for (const auto &p : map)
        {
            if (reversedMap.find(p.second) == reversedMap.end()) // 如果字母不在反向映射中
                reversedMap[p.second] = p.first;                 // 将字母与对应的单词建立反向映射
            else
            {
                if (reversedMap[p.second] != p.first) // 如果字母已经存在反向映射但与当前单词不同
                    return false;                     // 返回 false，表示不符合规律
            }
        }
        return true; // 如果所有映射都符合规律，返回 true
    }
```

#### 主要思路

1. **分词**: 利用 `istringstream` 从字符串 `s` 中逐个提取单词。

2. **正向映射**: 使用一个哈希表 `map` 来存储单词与模式字符之间的映射关系。

3. **反向映射**: 使用另一个哈希表 `reversedMap` 来确定模式字符与单词的反向映射。

4. **一致性检查**: 在映射建立过程中，检查每个单词和字符之间的对应关系是否一致。

#### 注意点

1. **边界条件**: 必须确保读取的单词数量与模式的长度一致，如果不一致则直接返回 `false`。

2. **双向映射**: 在建立映射时要同时考虑单向与反向映射，以确保没有冲突。例如，如果同一个字符可以对应多个不同的单词，则返回 `false`。

3. **性能考虑**: 使用哈希表进行查找，可以有效提高查找的效率。

---

## 387. 字符串中的第一个唯一字符

[力扣原题链接 (简单题)](https://leetcode.cn/problems/first-unique-character-in-a-string/description/)

给定一个字符串 `s` ，找到 _它的第一个不重复的字符，并返回它的索引_ 。如果不存在，则返回 `-1` 。

**示例 1：**

- **输入:** s = "leetcode"
- **输出:** 0

**示例 2:**

- **输入:** s = "loveleetcode"
- **输出:** 2

**示例 3:**

- **输入:** s = "aabb"
- **输出:** -1

**提示:**

- 1 <= `s.length` <= 10<sup>5</sup>
- `s` 只包含小写字母

### 参考代码

```cpp
    int firstUniqChar(string s)
    {
        unordered_map<char, int> map;
        // 统计每个字符出现的次数
        for (const auto &c : s)
        {
            ++map[c];
        }
        // 查找第一个不重复的字符并返回其索引
        for (int i = 0; i < s.length(); ++i)
        {
            if (map[s[i]] == 1)
                return i;
        }
        // 如果不存在不重复字符，返回 -1
        return -1;
    }
```

#### 关键步骤

1. **统计字符出现次数**：
	- 使用 `unordered_map` 记录每个字符在字符串中出现的次数。
	- 遍历字符串，对于每个字符 `c`，将其出现次数加一。

2. **查找第一个不重复字符**：
	- 再次遍历字符串，检查每个字符的出现次数。
	- 如果某个字符只出现一次，返回该字符的索引。

3. **返回结果**：
	- 如果遍历结束后没有找到不重复的字符，返回 -1。

---

## 594. 最长和谐子序列

[力扣原题链接 (简单题)](https://leetcode.cn/problems/longest-harmonious-subsequence/description/)

和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。

给你一个整数数组 `nums` ，请你在所有可能的 

子序列

 中找到最长的和谐子序列的长度。

数组的 **子序列** 是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

**示例 1：**

- **输入：** nums = [1,3,2,2,5,2,3,7]
- **输出：** 5
- **解释：** 最长和谐子序列是 `[3,2,2,2,3]`。

**示例 2：**

- **输入：** nums = [1,2,3,4]
- **输出：** 2
- **解释：** 最长和谐子序列是 `[1,2]`，`[2,3]` 和 `[3,4]`，长度都为 2。

**示例 3：**

- **输入：** nums = [1,1,1,1]
- **输出：** 0
- **解释：** 不存在和谐子序列。

**提示：**

- 1 <= `nums.length` <= 2 * 10<sup>4</sup>
- -10<sup>9</sup> <= `nums[i]` <= 10<sup>9</sup>

### 参考代码

```cpp
    int findLHS(vector<int> &nums)
    {
        // 声明一个映射，用于记录每个元素及其出现的次数
        map<int, int> mapN;
        // 遍历数组，统计每个数字出现的次数
        for (const auto &num : nums)
        {
            ++mapN[num]; // 对当前数字的计数加 1
        }
        // 如果映射只包含一个数字，则不可能构成和谐子序列，返回 0
        if (mapN.size() == 1)
            return 0;
        // 声明当前和以前的迭代器
        map<int, int>::iterator previous = mapN.begin(), current;
        int maxLen = 0;  // 最长和谐子序列长度
        int tempLen = 0; // 临时长度变量
        // 遍历映射，从第二个元素开始
        for (auto it = next(mapN.begin()); it != mapN.end(); ++it)
        {
            current = it; // 当前元素
            // 检查前一个元素与当前元素的差值是否为 1
            if (previous->first + 1 == current->first)
            {
                // 计算当前和前一个元素的出现次数之和，并与maxLen比较更新最大长度
                maxLen = (current->second + previous->second) > tempLen ? current->second + previous->second : tempLen;
                // 更新临时长度
                tempLen = maxLen;
            }
            // 更新前一个元素为当前元素
            previous = current;
        }
        // 返回找到的最长的和谐子序列的长度
        return maxLen;
    }
```

#### 代码思路

1. **统计元素出现次数**：
	- 使用 `map<int, int>` 来存储每个元素及其出现的次数。遍历 `nums` 数组，将每个数字的出现次数记录在映射中。

2. **检查映射中的元素个数**：
	- 如果映射中只有一个数字，则没有和谐子序列，直接返回 0。

3. **遍历映射**：
	- 使用迭代器遍历映射，从第二个元素开始，检查前一个元素与当前元素的差值是否为 1。
		- 如果差值为 1，计算这两个元素的出现次数之和，并更新 `maxLen`。

4. **返回结果**：
	- 最后返回找到的最长和谐子序列的长度 `maxLen`。

#### 注意点

- **边界情况**：在处理边界情况时，注意如果只有一个元素，和谐子序列的长度应直接返回 0。
- **迭代器的使用**：使用 `next(mapN.begin())` 从第二个元素开始遍历，对应前一个元素和当前元素的比较逻辑。
- **注意变量的初始化**：特别是 `maxLen` 和 `tempLen` 的初始值应该设置为 0，以确保在后续逻辑中能够正确比较和更新。

---

## 599. 两个列表的最小索引总和

[力扣原题链接 (简单题)](https://leetcode.cn/problems/minimum-index-sum-of-two-lists/description/)

假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们找到**索引和最小**的**共同喜爱的餐厅**。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。

**示例 1:**

- **输入:** list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
- **输出:** ["Shogun"]
- **解释:** 他们唯一共同喜爱的餐厅是“Shogun”。

**示例 2:**

- **输入:** list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["KFC", "Shogun", "Burger King"]
- **输出:** ["Shogun"]
- **解释:** 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。

**提示:**

- 1 <= `list1.length`, `list2.length` <= 1000
- 1 <= `list1[i].length`, `list2[i].length` <= 30
- `list1[i]` 和 `list2[i]` 由空格 `' '` 和英文字母组成。
- `list1` 的所有字符串都是 **唯一** 的。
- `list2` 中的所有字符串都是 **唯一** 的。
### 参考代码

```cpp
    vector<string> findRestaurant(vector<string> &list1, vector<string> &list2)
    {
        // 创建一个哈希表，用于存储 Andy 最喜欢的餐厅及其索引
        unordered_map<string, int> rest1
        // 将 list1 中的餐厅及其索引存入哈希表
        for (int i = 0; i < list1.size(); ++i)
        {
            rest1[list1[i]] = i;
        }
        // 存储结果的向量
        vector<string> res;
        // 初始化最小索引和
        int indexSum = INT_MAX, tempIndexSum = 0;
        // 遍历 Doris 的餐厅列表
        for (int j = 0; j < list2.size() && j <= indexSum; ++j)
        {
            // 如果 Doris 的餐厅不在 Andy 的列表中，跳过
            if (rest1.find(list2[j]) == rest1.end())
                continue;
            // 计算当前共同餐厅的索引和
            tempIndexSum = j + rest1[list2[j]];
            // 如果当前索引和小于已知的最小索引和，更新结果
            if (tempIndexSum < indexSum)
            {
                indexSum = tempIndexSum;
                res.clear();             // 清空之前的结果
                res.push_back(list2[j]); // 添加当前餐厅
            }
            // 如果相等，则将当前餐厅添加到结果中
            else if (tempIndexSum == indexSum)
                res.push_back(list2[j]);
        }
        // 返回找到的共同最爱餐厅
        return res;
    }
```

#### 主要步骤

1. **哈希表存储**：
	- 通过 `unordered_map` 创建一个哈希表 `rest1`，用于存储 Andy 的餐厅及对应的索引，使得查找更加高效。

2. **填充哈希表**：
	- 遍历 `list1`（Andy的餐厅列表），将餐厅名称作为键，索引作为值存入 `rest1`。

3. **遍历 Doris 的列表**：
	- 通过循环遍历 `list2`（Doris的餐厅列表），检查每个餐厅是否在 `rest1` 中存在。
	- 如果存在，计算该餐厅的索引和（即 Andy 和 Doris 的索引和）。

4. **更新结果**：
	- 维护最小索引和的变量 `indexSum`，并在找到更小的索引和时更新结果。
	- 如果当前的索引和等于最小索引和，则将该餐厅添加到结果中。

5. **返回结果**：
	- 函数返回一个包含共同最爱餐厅的向量。

#### 注意点

- **哈希表的使用**：哈希表的使用使得餐厅的查找变得高效，避免了重复的遍历。

- **清空结果向量**：在找到更小的索引和时，需要清空结果向量并添加新的餐厅。

- **使用`INT_MAX`**：初始化最小索引和为 `INT_MAX` 是一种常见的做法，用于确保可以找到最小值。
---

---
# 中等题
## 204. 计数质数

[力扣原题链接 (中等题)](https://leetcode.cn/problems/count-primes/description/)

给定整数 `n` ，返回 _所有小于非负整数 `n` 的质数的数量_ 。

**示例 1：**

- **输入：** n = 10
- **输出：** 4
- **解释：** 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

**示例 2：**

- **输入：** n = 0
- **输出：** 0

**示例 3：**

- **输入：** n = 1
- **输出：** 0

**提示：**

- 0 <= `n` <= 5 * 10<sup>6</sup>

### 参考代码

```cpp
    int countPrimes(int n)
    {
        // 如果 n 为 0 或 1，直接返回 0
        if (n == 0 || n == 1)
            return 0;
        // 初始化一个布尔类型的向量，用于标记质数
        vector<bool> nums(n, true);
        int times = 1, temp = 0;
        // 使用埃拉托斯特尼筛法标记非质数
        for (int i = 2; i <= nums.size() / 2; ++i)
        {
            if (nums[i] == true)
            {
                times = 2;
                temp = i * times;
                while (temp <= n - 1)
                {
                    nums[temp] = false;
                    temp = i * ++times;
                }
            }
        }
        // 统计质数的数量
        int count = 0;
        for (const auto &num : nums)
        {
            if (num == true)
                ++count;
        }
        // 返回质数的数量，减去 0 和 1 这两个非质数
        return count - 2;
    }
```

#### 主要步骤

1. **边界条件处理**：
	- 如果 `n` 为 0 或 1，直接返回 0，因为 0 和 1 都不是质数。

2. **初始化布尔向量**：
	- 使用 `vector<bool> nums(n, true)` 初始化一个布尔类型的向量，长度为 `n`，所有元素初始值为 `true`，表示默认所有数都是质数。

3. **埃拉托斯特尼筛法**：
	- 从 2 开始，遍历到 `n/2`，对于每个质数 `i`，将其倍数标记为非质数（即 `false`）。
	- 具体实现是通过一个 `while` 循环，不断将 `i` 的倍数标记为 `false`，直到倍数超过 `n-1`。

4. **统计质数数量**：
	- 遍历布尔向量 `nums`，统计值为 `true` 的元素数量。
	- 由于 0 和 1 不是质数，最终结果需要减去 2。

5. **返回结果**：
	- 返回统计的质数数量。

#### 注意点

- **边界条件**：函数一开始就处理了 `n` 为 0 或 1 的情况，避免了后续不必要的计算。

- **布尔向量的初始化**：使用 `vector<bool>` 来标记质数和非质数，初始值为 `true`，表示默认所有数都是质数。

-  **埃拉托斯特尼筛法的实现**：遍历范围是从 2 到 `n/2`，因为大于 `n/2` 的数不可能再有倍数小于 `n`。使用 `while` 循环来标记非质数，确保所有倍数都被正确标记。

- **统计质数数量**：在统计质数数量时，需要减去 0 和 1 这两个非质数。
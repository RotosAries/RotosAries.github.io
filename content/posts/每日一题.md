---
title: 每日一题
date: 2024-09-23
lastmod: 2024-09-24
tags:
  - 持续更新
  - C++
  - 力扣原题
categories:
  - 编程
  - 算法
image: /../image/每日一题.jpg
top: true
hideFromHomePage: false
share: true
draft: false
---

# 数组

## 414. 第三大的数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/third-maximum-number/description/)

给你一个非空数组，返回此数组中  **第三大的数** 。如果不存在，则返回数组中最大的数。

**示例 1：**

  - **输入：** [3, 2, 1]
  - **输出：** 1
  - **解释：** 第三大的数是 1 。

**示例 2：**

  - **输入：** [1, 2]
  - **输出：** 2
  - **解释：** 第三大的数不存在, 所以返回最大的数 2 。

**示例 3：**
  - **输入：** [2, 2, 3, 1]
  - **输出：** 1
  - **解释：** 注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。

### 参考代码

```C++
int thirdMax(vector<int> &nums)
    {
        // 初始化最大值、中间值和最小值为最小的长整型值
        long long maxNum = LONG_LONG_MIN, midNum = LONG_LONG_MIN, minNum = LONG_LONG_MIN;
        // 遍历数组中的每一个数字
        for (auto n : nums)
        {
            // 如果当前数字大于最大值，则更新最大值、中间值和最小值
            if (n > maxNum)
            {
                minNum = midNum; // 更新最小值为之前的中间值
                midNum = maxNum; // 更新中间值为之前的最大值
                maxNum = n;      // 更新最大值为当前数字
            }
            // 如果当前数字在最大值和中间值之间，则更新中间值和最小值
            else if (n > midNum && n < maxNum)
            {
                minNum = midNum; // 更新最小值为之前的中间值
                midNum = n;      // 更新中间值为当前数字
            }
            // 如果当前数字在中间值和最小值之间，则更新最小值
            else if (n > minNum && n < midNum)
            {
                minNum = n; // 更新最小值为当前数字
            }
        }
        // 如果最小值仍未更新，返回最大值
        if (minNum == LONG_LONG_MIN)
            return maxNum; // 返回最大值
        else
            return minNum; // 返回第三大的数字
    }
```

#### 关键变量

- **maxNum**：当前找到的最大值。

- **midNum**：当前找到的中间值，即第二大值。

- **minNum**：当前找到的最小值，即第三大值。
  这些变量都被初始化为最小的长整型值 `LONG_LONG_MIN`，确保在比较时不会出现意外的结果。

#### 遍历数组

通过范围基于 `for` 循环遍历 `nums` 数组中的每一个元素 `n`，进行以下判断：

1. 更新最大值：
	- 如果当前元素 `n` 大于 `maxNum`，则：
		- 将 `midNum` 更新为原先的 `maxNum`。
		- 将 `minNum` 更新为原先的 `midNum`。
		- 将 `maxNum` 更新为当前元素 `n`。
1. 更新中间值：
	- 如果当前元素 `n` 在 `maxNum` 和 `midNum` 之间（即大于 `midNum` 且小于 `maxNum`），则：
		- 将 `minNum` 更新为原先的 `midNum`。
		- 将 `midNum` 更新为当前元素 `n`。
2. 更新最小值：
	- 如果当前元素 `n` 在 `midNum` 和 `minNum` 之间（即大于 `minNum` 且小于 `midNum`），则：
		- 将 `minNum` 更新为当前元素 `n`。

#### 返回结果

在遍历完数组后，检查 `minNum`：

- 如果 `minNum` 仍为 `LONG_LONG_MIN`，表示未找到第三大元素，返回 `maxNum`。

- 否则，返回 `minNum`，即第三大的数字。

---
## 581. 最短无序连续子数组

[力扣原题链接 (中等题)](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/)

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 **最短** 子数组，并输出它的长度。

**示例 1：**

- **输入：** nums = [2,6,4,8,10,9,15]
- **输出：** 5
- **解释：** 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

**示例 2：**

- **输入：** nums = [1,2,3,4]
- **输出：** 0

**示例 3：**

- **输入：** nums = [1]
- **输出：** 0

### 参考代码

```C++
    int findUnsortedSubarray(vector<int> &nums)
    {
        // 如果数组只有一个元素，则不需要排序，直接返回0
        if (nums.size() == 1)
            return 0;
        int maxLeft = nums[0], minRight = nums[nums.size() - 1];
        int left = 0, right = nums.size() - 1;
        // 从左到右遍历数组，找出无序子数组的左边界
        for (int i = 0; i < nums.size(); ++i)
        {
            // 如果当前元素大于等于当前最大值，则更新最大值
            if (nums[i] >= maxLeft)
            {
                maxLeft = nums[i];
            }
            // 否则，更新左边界
            else
            {
                left = i;
            }
        }
        // 从右到左遍历数组，找出无序子数组的右边界
        for (int j = nums.size() - 1; j >= 0; --j)
        {
            // 如果当前元素小于等于当前最小值，则更新最小值
            if (nums[j] <= minRight)
            {
                minRight = nums[j];
            }
            // 否则，更新右边界
            else
            {
                right = j;
            }
        }
        // 返回无序子数组的长度，如果没有无序子数组则返回0
        return left > right ? left - right + 1 : 0;
    }
```

#### 关键步骤

1. **边界条件判断**：

   - 首先检查数组是否只有一个元素，如果是，则无需排序，直接返回 0。

2. **初始化变量**：

   - `maxLeft`：从左侧开始遍历时已找到的最大值，初始化为数组的第一个元素。
   - `minRight`：从右侧开始遍历时已找到的最小值，初始化为数组的最后一个元素。
   - `left` 和 `right`：记录无序子数组的左右边界，初始值分别为 0 和数组长度减 1。

3. **查找无序子数组的左边界**：

   - 从左到右遍历数组：
     - 如果当前元素大于等于 `maxLeft`，更新 `maxLeft`。
     - 否则，发生了无序，因此更新左边界 `left`。

4. **查找无序子数组的右边界**：

   - 从右到左遍历数组：
     - 如果当前元素小于等于 `minRight`，更新 `minRight`。
     - 否则，发生了无序，因此更新右边界 `right`。

5. **计算并返回无序子数组的长度**：
   - 如果 `left` 大于 `right`，则说明找到了无序子数组，返回其长度 `left - right + 1`。
   - 否则，表示整个数组已经有序，返回 0。

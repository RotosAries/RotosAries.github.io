---
title: 每日一题
date: 2024-09-23
lastmod: 2024-09-27
tags:
  - 持续更新
  - C++
  - 力扣原题
categories:
  - 编程
  - 算法
image: /../image/每日一题.jpg
top: true
hideFromHomePage: false
share: true
draft: false
---

# 数组

## 414. 第三大的数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/third-maximum-number/description/)

给你一个非空数组，返回此数组中  **第三大的数** 。如果不存在，则返回数组中最大的数。

**示例 1：**

  - **输入：** [3, 2, 1]
  - **输出：** 1
  - **解释：** 第三大的数是 1 。

**示例 2：**

  - **输入：** [1, 2]
  - **输出：** 2
  - **解释：** 第三大的数不存在, 所以返回最大的数 2 。

**示例 3：**
  - **输入：** [2, 2, 3, 1]
  - **输出：** 1
  - **解释：** 注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。

### 参考代码

```cpp
int thirdMax(vector<int> &nums)
    {
        // 初始化最大值、中间值和最小值为最小的长整型值
        long long maxNum = LONG_LONG_MIN, midNum = LONG_LONG_MIN, minNum = LONG_LONG_MIN;
        // 遍历数组中的每一个数字
        for (auto n : nums)
        {
            // 如果当前数字大于最大值，则更新最大值、中间值和最小值
            if (n > maxNum)
            {
                minNum = midNum; // 更新最小值为之前的中间值
                midNum = maxNum; // 更新中间值为之前的最大值
                maxNum = n;      // 更新最大值为当前数字
            }
            // 如果当前数字在最大值和中间值之间，则更新中间值和最小值
            else if (n > midNum && n < maxNum)
            {
                minNum = midNum; // 更新最小值为之前的中间值
                midNum = n;      // 更新中间值为当前数字
            }
            // 如果当前数字在中间值和最小值之间，则更新最小值
            else if (n > minNum && n < midNum)
            {
                minNum = n; // 更新最小值为当前数字
            }
        }
        // 如果最小值仍未更新，返回最大值
        if (minNum == LONG_LONG_MIN)
            return maxNum; // 返回最大值
        else
            return minNum; // 返回第三大的数字
    }
```

#### 关键变量
- **maxNum**：当前找到的最大值。

- **midNum**：当前找到的中间值，即第二大值。

- **minNum**：当前找到的最小值，即第三大值。
  这些变量都被初始化为最小的长整型值 `LONG_LONG_MIN`，确保在比较时不会出现意外的结果。

#### 遍历数组
通过范围基于 `for` 循环遍历 `nums` 数组中的每一个元素 `n`，进行以下判断：

1. 更新最大值：
	- 如果当前元素 `n` 大于 `maxNum`，则：
		- 将 `midNum` 更新为原先的 `maxNum`。
		- 将 `minNum` 更新为原先的 `midNum`。
		- 将 `maxNum` 更新为当前元素 `n`。
1. 更新中间值：
	- 如果当前元素 `n` 在 `maxNum` 和 `midNum` 之间（即大于 `midNum` 且小于 `maxNum`），则：
		- 将 `minNum` 更新为原先的 `midNum`。
		- 将 `midNum` 更新为当前元素 `n`。
2. 更新最小值：
	- 如果当前元素 `n` 在 `midNum` 和 `minNum` 之间（即大于 `minNum` 且小于 `midNum`），则：
		- 将 `minNum` 更新为当前元素 `n`。

#### 返回结果
在遍历完数组后，检查 `minNum`：

- 如果 `minNum` 仍为 `LONG_LONG_MIN`，表示未找到第三大元素，返回 `maxNum`。

- 否则，返回 `minNum`，即第三大的数字。

---
## 581. 最短无序连续子数组

[力扣原题链接 (中等题)](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/)

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 **最短** 子数组，并输出它的长度。

**示例 1：**

- **输入：** nums = [2,6,4,8,10,9,15]
- **输出：** 5
- **解释：** 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

**示例 2：**

- **输入：** nums = [1,2,3,4]
- **输出：** 0

**示例 3：**

- **输入：** nums = [1]
- **输出：** 0

### 参考代码

```cpp
    int findUnsortedSubarray(vector<int> &nums)
    {
        // 如果数组只有一个元素，则不需要排序，直接返回0
        if (nums.size() == 1)
            return 0;
        int maxLeft = nums[0], minRight = nums[nums.size() - 1];
        int left = 0, right = nums.size() - 1;
        // 从左到右遍历数组，找出无序子数组的左边界
        for (int i = 0; i < nums.size(); ++i)
        {
            // 如果当前元素大于等于当前最大值，则更新最大值
            if (nums[i] >= maxLeft)
            {
                maxLeft = nums[i];
            }
            // 否则，更新左边界
            else
            {
                left = i;
            }
        }
        // 从右到左遍历数组，找出无序子数组的右边界
        for (int j = nums.size() - 1; j >= 0; --j)
        {
            // 如果当前元素小于等于当前最小值，则更新最小值
            if (nums[j] <= minRight)
            {
                minRight = nums[j];
            }
            // 否则，更新右边界
            else
            {
                right = j;
            }
        }
        // 返回无序子数组的长度，如果没有无序子数组则返回0
        return left > right ? left - right + 1 : 0;
    }
```

#### 关键步骤

1. **边界条件判断**：
   - 首先检查数组是否只有一个元素，如果是，则无需排序，直接返回 0。

2. **初始化变量**：
   - `maxLeft`：从左侧开始遍历时已找到的最大值，初始化为数组的第一个元素。
   - `minRight`：从右侧开始遍历时已找到的最小值，初始化为数组的最后一个元素。
   - `left` 和 `right`：记录无序子数组的左右边界，初始值分别为 0 和数组长度减 1。

3. **查找无序子数组的左边界**：
   - 从左到右遍历数组：
     - 如果当前元素大于等于 `maxLeft`，更新 `maxLeft`。
     - 否则，发生了无序，因此更新左边界 `left`。

4. **查找无序子数组的右边界**：
   - 从右到左遍历数组：
     - 如果当前元素小于等于 `minRight`，更新 `minRight`。
     - 否则，发生了无序，因此更新右边界 `right`。

5. **计算并返回无序子数组的长度**：
   - 如果 `left` 大于 `right`，则说明找到了无序子数组，返回其长度 `left - right + 1`。
   - 否则，表示整个数组已经有序，返回 0。
---
## 724. 寻找数组的中心下标

[力扣原题链接 (简单题)](https://leetcode.cn/problems/find-pivot-index/description/)

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

**示例 1：**

- **输入：** nums = [1, 7, 3, 6, 5, 6]
- **输出：** 3
- **解释：** 中心下标是 3 。左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。

**示例 2：**

- **输入：** nums = [1, 2, 3]
- **输出：** -1
- **解释：** 数组中不存在满足此条件的中心下标。

**示例 3：**

- **输入：** nums = [2, 1, -1]
- **输出：** 0
- **解释：** 中心下标是 0 。左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
### 参考代码

```cpp
    int pivotIndex(vector<int> &nums)
    {
        auto beg = nums.begin(); // 数组的起始迭代器
        auto end = nums.end();   // 数组的结束迭代器
        int result = -1;         // 初始化结果为 -1
        int leftSum = 0;         // 左侧元素的和
        int rightSum = 0;        // 右侧元素的和
        // 从后向前遍历数组
        for (int i = nums.size() - 1; i >= 0; --i)
        {
            auto it = nums.begin() + i; // 当前元素的迭代器
            // 计算左侧元素的和
            leftSum = (i == 0) ? 0 : accumulate(beg, it, 0);
            // 计算右侧元素的和
            rightSum = (i == nums.size() - 1) ? 0 : accumulate(it + 1, end, 0);
            // 如果左侧和等于右侧和，则更新结果
            if (leftSum == rightSum)
                result = i; // 找到中心下标
        }
        return result; // 返回找到的中心下标
    }
```

#### 核心逻辑

1. **初始化**:

	- `result` 初始化为 -1，表示默认没有找到任何中心下标。
	- `leftSum` 和 `rightSum` 分别用于计算左侧和右侧的元素和。

2. **遍历数组**:

	- 使用一个反向循环，从数组的最后一个元素开始向前遍历。
	- 对于每一个元素，计算其左侧和右侧的元素和。

3. **计算和**:

	- 如果当前下标为 0，则左侧元素和视为 0；如果当前下标为数组的最后一个索引，则右侧元素和视为 0。
	- 使用 `accumulate` 函数计算指定范围内元素的和。

4. **中心下标判定**:

	- 判断左侧和是否等于右侧和，如果相等，则更新 `result` 为当前下标。

5. **返回结果**:

	- 遍历完成后返回 `result`，即找到的中心下标或者 -1。
---

## 747. 至少是其他数字两倍的最大数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/largest-number-at-least-twice-of-others/description/)

给你一个整数数组 `nums` ，其中总是存在 **唯一的** 一个最大整数 。

请你找出数组中的最大元素并检查它是否 **至少是数组中每个其他数字的两倍** 。如果是，则返回 **最大元素的下标** ，否则返回 `-1` 。

**示例 1：**

- **输入：** nums = [3,6,1,0]
- **输出：** 1
- **解释：** 6是最大的整数，对于数组中的其他整数，6至少是数组中其他元素的两倍。6的下标是1，所以返回 1 。

**示例 2：**

- **输入：** nums = [1,2,3,4]
- **输出：** -1
- **解释：** 4 没有超过 3 的两倍大，所以返回 -1 。
### 参考代码

```cpp
    int dominantIndex(vector<int> &nums)
    {
        vector<int> temp = nums;        // 创建一个副本以保留原始数组
        sort(nums.begin(), nums.end()); // 对数组进行排序
        // 检查最大元素是否至少是第二大元素的两倍
        if (nums[nums.size() - 1] / 2 >= nums[nums.size() - 2])
        {
            int max = nums[nums.size() - 1]; // 获取最大元素
            // 遍历原始数组查找最大元素的下标
            for (int i = 0; i < temp.size(); ++i)
            {
                if (max == temp[i]) // 如果找到了最大元素
                    return i;       // 返回其下标
            }
        }
        return -1; // 如果条件不满足，返回 -1
    }
```

#### 实现步骤

1. **创建副本**：使用 `vector<int> temp = nums;` 创建原始数组的副本，以便后续查找最大元素的下标时不受排序的影响。

2. **排序**：使用 `sort(nums.begin(), nums.end());` 对数组进行排序，以便可以快速找到最大元素及其相邻元素（第二大元素）。

3. **条件判断**：
	- 检查最大元素是否至少是第二大元素的两倍，使用条件 `if (nums[nums.size() - 1] / 2 >= nums[nums.size() - 2])` 实现。
	- 如果条件满足，继续下一步；否则返回 -1。

5. **查找下标**：
	- 使用循环遍历副本数组 `temp`，找到最大元素并返回其下标。
	- 利用条件 `if (max == temp[i])` 判断当前元素是否为最大元素。

6. **返回结果**：
	- 如果找到了符合条件的最大元素，返回它的下标；如果没有，返回 -1。
---
## 830 最大分组的位置

[力扣原题链接 (简单题)](https://leetcode.cn/problems/positions-of-large-groups/description/)

在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 `s = "abbxxxxzyy"` 中，就含有 `"a"`, `"bb"`, `"xxxx"`, `"z"` 和 `"yy"` 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。

找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。

**示例 1：**

- **输入：** s = "abbxxxxzzy"
- **输出：** `[[3,6]]`
- **解释：** `"xxxx" 是一个起始于 3 且终止于 6 的较大分组`。

**示例 2：**

- **输入：** s = "abc"
- **输出：** `[]`
- **解释：** "a","b" 和 "c" 均不是符合要求的较大分组。

**示例 3：**

- **输入：** s = "abcdddeeeeaabbbcd"
- **输出：** `[[3,5],[6,9],[12,14]]`
- **解释：** 较大分组为 "ddd", "eeee" 和 "bbb"

**示例 4：**

- **输入：** s = "aba"
- **输出：** `[]`

### 参考代码

```cpp
    vector<vector<int>> largeGroupPositions(string s)
    {
        // 如果字符串长度小于 3，或者长度为 3 但三个字符不相同，则返回空结果
        if (s.length() < 3 || (s.length() == 3 && s[0] != s[1]))
            return {};
        // 在字符串末尾添加一个不会出现的字符，便于处理最后一个分组
        s.push_back('0');
        vector<int> temp;           // 用于存储当前较大分组的起始和结束位置
        vector<vector<int>> result; // 存储所有较大分组的结果
        // 遍历字符串的每个字符
        for (int i = 0; i < s.length(); ++i)
        {
            // 如果 temp 不为空且当前字符与 temp 开始字符不同，表示一个分组结束
            if (!temp.empty() && s[i] != s[temp[0]])
            {
                temp.push_back(i - 1);  // 添加当前分组的结束位置
                result.push_back(temp); // 将当前分组添加到结果中
                temp.clear();           // 清空 temp，准备下一个分组
            }
            // 如果 temp 不为空且当前字符与 temp 开始字符相同，继续
            if (!temp.empty() && s[i] == s[temp[0]])
            {
                continue;
            }
            // 检查当前字符是否与后面的两个字符相同
            if (s[i] == s[i + 1] && s[i] == s[i + 2])
            {
                temp.push_back(i); // 记录当前分组的起始位置
                i += 2;            // 跳过后两个相同字符
            }
        }
        return result; // 返回所有的较大分组
    }
```

#### 关键步骤

1. **参数与返回值**:
	- 输入：一个字符串 `s`。
	- 输出：一个二维向量 `vector<vector<int>>`，其中每个子向量包含一个较大分组的起始和结束位置。

2. **处理边界条件**:
	- 如果字符串长度小于 3，直接返回空的结果。
	- 在字符串末尾附加一个不会与原字符串重复的字符（如 `'0'`），以便在遍历时能够完整处理最后一个分组。

3. **变量定义**:
	- `temp`：用于临时存储当前较大分组的起始和结束位置。
	- `result`：最终存储所有较大分组的结果。

4. **遍历字符串**:
	- 使用 `for` 循环遍历字符串的每个字符。
	- 如果当前字符与 `temp` 中的起始字符不相同，表示一个分组结束，更新 `temp` 和 `result`，然后清空 `temp`。
	- 如果当前字符与 `temp` 中的起始字符相同，则跳过当前迭代。
	- 检查当前字符与其后两个字符是否相同，如果相同，记录起始位置并调整迭代变量 `i`，以跳过连续字符。

5. **返回结果**:
	- 函数返回所有找到的较大分组的起始和结束位置。
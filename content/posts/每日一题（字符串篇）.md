---
title: 每日一题（字符串篇）
date: 2024-11-05
lastmod: 2024-11-09
tags:
  - 持续更新
  - C++
  - 字符串
  - 力扣原题
categories:
  - 编程
  - 算法
image: /../image/每日一题(字符串篇).jpg
top: true
hideFromHomePage: false
share: true
draft: false
---

# 简单题

## 13. 罗马数字转整数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/roman-to-integer/description/)

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

| **字符** | **数值** |
| ------ | ------ |
| I      | 1      |
| V      | 5      |
| X      | 10     |
| L      | 50     |
| C      | 100    |
| D      | 500    |
| M      | 1000   |

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**示例 1:**

- **输入:** s = "III"
- **输出:** 3

**示例 2:**

- **输入:** s = "IV"
- **输出:** 4

**示例 3:**

- **输入:** s = "IX"
- **输出:** 9

**示例 4:**

- **输入:** s = "LVIII"
- **输出:** 58
- **解释:** L = 50, V= 5, III = 3.

**示例 5:**

- **输入:** s = "MCMXCIV"
- **输出:** 1994
- **解释:** M = 1000, CM = 900, XC = 90, IV = 4.

### 参考代码
```cpp
    int romanToInt(string s)
    {
        // 创建一个哈希表，将罗马数字对应的整数值进行映射
        unordered_map<char, int> map = {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}};
        char preChar = 'I'; // 初始化前一个字符为 'I'
        int sum = 0;        // 用于存储转换后的整数总和
        // 从字符串的最后一个字符开始向前遍历
        for (int i = s.length() - 1; i >= 0; --i)
        {
            // 如果当前字符对应的值小于前一个字符对应的值，则减去当前值
            if (map[s[i]] < map[preChar])
                sum -= map[s[i]];
            else // 否则，加上当前值
                sum += map[s[i]];
            preChar = s[i]; // 更新前一个字符
        }
        return sum; // 返回最终计算出的整数值
    }
```

#### 代码分析

1. **哈希表的使用**：
	- 利用 `unordered_map<char, int>` 创建了一个哈希表，将罗马数字字符（如 'I', 'V', 'X' 等）对应的整数值进行了映射。这使得查找每个罗马字符的整数值变得高效。

2. **初始化变量**：
	- `preChar` 用于记录前一个字符，初始设为 'I'。
	- `sum` 用于累计转换后的总和，初始为 0。

3. **从后向前遍历**：
	- 该算法自字符串的最后一个字符开始向前遍历，这是处理罗马数字的一种常见方法。
	- 遍历过程中比较当前字符与前一个字符对应的值：
		- 若当前字符的值小于前一个字符的值，则表示需减去当前值。
		 - 否则，直接加上当前值。

4. **更新前一个字符**：
	- 在每次循环结束后，更新 `preChar` 为当前字符，以便下次判断。

5. **返回结果**：
	- 最终返回 `sum`，即转换得到的整数值。

#### 注意点

- **字符顺序的重要性**：罗马数字的构成规则决定了从后向前遍历是必要的，这是因为可能会出现小的罗马数字在大的罗马数字前面的情况（如 IV = 4）。
- **边界条件**：应注意输入字符串的合法性，例如只允许包含有效的罗马数字字符。
- **性能考虑**：该实现的时间复杂度为 O(n)，其中 n 是输入字符串的长度；空间复杂度为 O(1)，因映射表不会随输入大小而变化。
- **哈希表的适用性**：使用哈希表可以快速查找罗马字符的值，这是提高效率的重要设计。
---

## 67. 二进制求和

[力扣原题链接 (简单题)](https://leetcode.cn/problems/add-binary/description/)

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

**示例 1：**

- **输入:** a = "11", b = "1"
- **输出：** "100"

**示例 2：**

- **输入：** a = "1010", b = "1011"
- **输出：** "10101"

### 参考代码

```cpp
    string addBinary(string a, string b)
    {
        vector<int> numA, numB, res; // 用于存储二进制数字和结果的向量
        // 将二进制字符串 a 转换为数字向量 numA
        for (const auto &nA : a)
        {
            if (nA == '1')
                numA.push_back(1); // 如果是 '1'，则添加 1
            else
                numA.push_back(0); // 否则添加 0
        }
        // 将二进制字符串 b 转换为数字向量 numB
        for (const auto &nB : b)
        {
            if (nB == '1')
                numB.push_back(1); // 如果是 '1'，则添加 1
            else
                numB.push_back(0); // 否则添加 0
        }
        int k = 0, sum = 0; // k 用于记录进位，sum 用于计算和
        // 当 numA 和 numB 都不为空时进行加法运算
        while (!numA.empty() && !numB.empty())
        {
            sum = k + numA.back() + numB.back(); // 计算当前位的和
            k = 0;                               // 初始化进位
            if (sum / 2 > 0)                     // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numA.pop_back();        // 移除处理过的数字
            numB.pop_back();        // 移除处理过的数字
        }
        // 处理 numA 还剩余的部分
        while (!numA.empty())
        {
            sum = k + numA.back(); // 计算当前位的和
            k = 0;                 // 初始化进位
            if (sum / 2 > 0)       // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numA.pop_back();        // 移除处理过的数字
        }
        // 如果 numB 为空且还有进位，则添加 1
        if (numB.empty() && k > 0)
        {
            res.push_back(1);
            k = 0; // 清除进位
        }
        // 处理 numB 还剩余的部分
        while (!numB.empty())
        {
            sum = k + numB.back(); // 计算当前位的和
            k = 0;                 // 初始化进位
            if (sum / 2 > 0)       // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numB.pop_back();        // 移除处理过的数字
        }
        // 如果还有进位，添加 1
        if (k > 0)
            res.push_back(1);
        // 将结果向量转换为字符串
        string s(res.size(), '0');
        for (size_t i = 0; i < res.size(); ++i)
        {
            s[i] = static_cast<char>(res[i] + '0'); // 将数字转换为字符
        }
        // 反转字符串以得到正确的结果
        return string(s.rbegin(), s.rend());
    }
```

#### 主要步骤

1. **字符串转换**：
	- 将二进制字符串 `a` 和 `b` 转换为整数向量 `numA` 和 `numB`。如果字符为 `'1'`，则在向量中添加 `1`，否则添加 `0`。

2. **加法运算**：
	- 使用两个 `while` 循环遍历两个向量，直到至少一个向量为空，逐位对两个二进制位进行加法计算，同时处理进位 `k`。
	- 如果当前位的和大于等于2，则进位 `k` 设为1，否则进位为0。

3. **处理剩余位**：
	- 如果一个向量处理完了，继续处理另一个向量中剩余的位及进位。

4. **构建结果字符串**：
	- 最后，将结果向量 `res` 转换为字符串，注意需要反转字符串以得到正确的二进制表示。

#### 注意点

- **进位处理**：在每次计算时，要注意处理进位，其值可能会影响当前位的和。
- **字符串反转**：结果向量存储的是从最低位开始的计算结果，因此在返回前需要反转字符串顺序。
- **字符转换**：在向结果字符串中插入数字时，通过加 `'0'` 转换整数为字符。
- **边界条件**：需要考虑到一个或者两个输入字符串为空的情况，以防止出现错误。

---

## 434. 字符串中的单词数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/number-of-segments-in-a-string/description/)

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**

- **输入:** "Hello, my name is John"
- **输出:** 5
- **解释:** 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。

### 参考代码

```cpp
    int countSegments(string s)
    {
        // 如果字符串为空，则返回0
        // if (s.empty())
        //     return 0;
        int count = 0; // 单词计数器
        s.push_back(' '); // 在字符串末尾添加空格，以便处理最后一个单词
        // 遍历字符串
        for (size_t i = 0; i < s.length() - 1; ++i)
        {
            // 如果当前字符不是空格且下一个字符是空格，则说明找到了一个单词
            if (!isspace(s[i]) && isspace(s[i + 1]))
                ++count; // 增加单词计数
        }
        return count; // 返回单词总数
    }
```

#### 代码逻辑

1. **特殊情况处理**:
	- 在字符串末尾添加一个空格，以确保最后一个单词能够被正确识别。这是为了避免处理最后一个单词时遗漏。

2. **初始化计数器**:
	- 定义一个变量 `count` 用于记录单词的数量，并初始化为 0。

3. **遍历字符串**:
	- 使用 `for` 循环遍历字符串的每个字符，检查当前字符和下一个字符：
		 - 如果当前字符不是空格且下一个字符是空格，说明找到了一个完整的单词，计数器 `count` 加一。

4. **返回结果**:
	- 循环结束后，返回单词总数。

#### 注意点

- **字符判断**：使用 `isspace` 函数来判断字符是否为空格，确保在统计时只考虑空格。
- **边界情况**：如果字符串为空，虽然在代码中可以处理，但可以提前返回 0 以优化性能（这部分已注释）。

---

## 680. 验证回文串 II

[力扣原题链接 (简单题)](https://leetcode.cn/problems/valid-palindrome-ii/description/)

给你一个字符串 `s`，**最多** 可以从中删除一个字符。

请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。

**示例 1：**

- **输入：** s = "aba"
- **输出：** true

**示例 2：**

- **输入：** s = "abca"
- **输出：** true
- **解释：** 你可以删除字符 'c' 。

**示例 3：**

- **输入：** s = "abc"
- **输出：** false

### 参考代码

```cpp
    bool validPalindrome(string s)
    {
        int left = 0, right = s.length() - 1; // 初始化左右指针
        // 检查当前字符串是否是回文
        while (left <= right && s[left] == s[right])
        {
            ++left;  // 向右移动左指针
            --right; // 向左移动右指针
        }
        // 如果左指针大于右指针，说明字符串是回文
        if (left > right)
            return true;
        // 保存当前的左右指针位置
        int tempLeft = left, tempRight = right;
        // 尝试删除左边的字符
        ++left; // 删除左边的字符
        while (left <= right && s[left] == s[right])
        {
            ++left;  // 向右移动左指针
            --right; // 向左移动右指针
        }
        // 如果删除左边字符后成为回文，返回 true
        if (left > right)
            return true;
        // 恢复原来的左右指针位置
        left = tempLeft;
        right = tempRight;
        // 尝试删除右边的字符
        --right; // 删除右边的字符
        while (left <= right && s[left] == s[right])
        {
            ++left;  // 向右移动左指针
            --right; // 向左移动右指针
        }
        // 如果删除右边字符后成为回文，返回 true；否则返回 false
        if (left > right)
            return true;
        else
            return false;
    }
```

#### 主要步骤

1. **初始化指针**：分别设置左右指针 `left` 和 `right`，指向字符串的两端。

2. **检查是否是回文**：通过循环比较左右指针指向的字符，如果相等则左右指针同时向内移动；如果不相等，则记录当前的指针位置以备后续操作。

3. **尝试删除字符**：
	- **删除左边的字符**：移动左指针向右，再次检查是否形成回文。
	- **恢复指针位置**：在尝试删除右边字符之前，需将指针恢复到未删除状态。
	- **删除右边的字符**：移动右指针向左，再次检查是否形成回文。

4. **结果返回**：如果经过删除一个字符后，满足回文条件则返回 `true`，否则返回 `false`。

#### 注意点

- **两次循环的条件**：在检查字符串是否为回文时，注意需要在左右指针未交汇前进行比较。
- **指针恢复**：在删除一个字符后，要将左右指针恢复，确保下一次操作从正确的位置开始。
- **边界条件处理**：需要考虑空字符串和单字符字符串的情况，这些特殊情况在逻辑上应当直接返回 `true`。

---

---

# 中等题
## 686. 重复叠加字符串匹配

[力扣原题链接 (中等题)](https://leetcode.cn/problems/repeated-string-match/description/)

给定两个字符串 `a` 和 `b`，寻找重复叠加字符串 `a` 的最小次数，使得字符串 `b` 成为叠加后的字符串 `a` 的子串，如果不存在则返回 `-1`。

**注意：**字符串 `"abc"` 重复叠加 0 次是 `""`，重复叠加 1 次是 `"abc"`，重复叠加 2 次是 `"abcabc"`。

**示例 1：**

- **输入：** a = "abcd", b = "cdabcdab"
- **输出：** 3
- **解释：** a 重复叠加三遍后为 "ab**cdabcdab**cd", 此时 b 是其子串。

**示例 2：**

- **输入：** a = "a", b = "aa"
- **输出：** 2

**示例 3：**

- **输入：** a = "a", b = "a"
- **输出：** 1

**示例 4：**

- **输入：** a = "abc", b = "wxyz"
- **输出：** -1

### 参考代码

```cpp
    int repeatedStringMatch(string a, string b)
    {
        deque<int> deque; // 用于存储字符 a 中与 b 的首字符相同的所有索引
        // 遍历字符串 a，寻找与字符串 b 的首字符相同的字符索引
        for (int i = 0; i < a.length(); ++i)
        {
            if (a[i] == b[0])       // 如果找到了相同的字符
                deque.push_back(i); // 将索引加入队列
        }
        if (deque.empty()) // 如果队列为空，说明 a 中没有与 b 的首字符相同的字符
            return -1;     // 返回 -1
        int h = 0, m = 0, n = 0, count = 0; // 初始化变量 h（队列头部）、m（当前比较 a 的索引）、n（当前比较 b 的索引）、count（重复次数计数）
        // 当队列不为空时，继续处理
        while (!deque.empty())
        {
            h = deque.front(); // 取出队列的头部元素
            m = h;             // 初始化 m 为当前比较的 a 的索引
            n = 0;             // 初始化 b 的索引
            count = 0;         // 重复次数重置为 0
            deque.pop_front(); // 移除队列头部元素
            // 对字符串 b 进行遍历
            while (n < b.length())
            {
                if (m == a.length()) // 如果 m 越界，说明需要重复叠加 a
                {
                    m = 0;   // 重置 m
                    ++count; // 增加叠加次数
                }
                if (a[m] != b[n]) // 如果 a[m] 和 b[n] 不相等，说明匹配失败
                    break;        // 退出当前比较
                ++m; // 移动到 a 的下一个字符
                ++n; // 移动到 b 的下一个字符
            }
            if (n == b.length())  // 如果 n 到达了 b 的末尾，说明成功匹配
                return count + 1; // 返回当前叠加次数加 1
        }
        return -1; // 如果没有找到匹配，返回 -1
    }
```

#### 代码逻辑

1. **寻找匹配的起始点**：首先扫描字符串 `a`，找到所有和字符串 `b` 的首字符相同的索引位置，并将这些索引存放在一个双端队列 `deque` 中。

2. **特例处理**：如果 `deque` 为空，说明 `a` 中没有与 `b` 的首字符相同的字符，直接返回 -1。

3. **匹配过程**：
	- 循环处理队列中的每个索引，初始化指针 `m`（指向 `a`）和 `n`（指向 `b`），以及计数器 `count` 记录重复叠加的次数。
	- 对于字符串 `b`，逐字符进行比较：
		- 如果 `m` 超出了 `a` 的长度，则说明需要重复叠加 `a`，此时重置 `m` 并增加 `count`。
		- 若 `a[m]` 和 `b[n]` 不匹配，则退出当前的匹配尝试。
	- 如果 `n` 遍历完了字符串 `b`，则说明成功找到了匹配，返回当前的叠加次数加 1。

4. **返回值**：在无法匹配的情况下，最后返回 -1。

#### 注意点

- **双端队列的使用**：`deque` 用于存储所有可能的起始匹配位置，便于在匹配失败后，可以快速尝试下一个可能的起始位置。
- **边界条件**：处理好 `m` 超出 `a` 长度的情况，确保在需要的时候可以正确地进行字符串的重复叠加。
---
title: 每日一题（字符串篇）
date: 2024-11-05
lastmod: 2024-11-07
tags:
  - 持续更新
  - C++
  - 字符串
  - 力扣原题
categories:
  - 编程
  - 算法
image: /../image/每日一题(字符串篇).jpg
top: true
hideFromHomePage: false
share: true
draft: false
---

# 简单题

## 13. 罗马数字转整数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/roman-to-integer/description/)

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

| **字符** | **数值** |
| ------ | ------ |
| I      | 1      |
| V      | 5      |
| X      | 10     |
| L      | 50     |
| C      | 100    |
| D      | 500    |
| M      | 1000   |

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**示例 1:**

- **输入:** s = "III"
- **输出:** 3

**示例 2:**

- **输入:** s = "IV"
- **输出:** 4

**示例 3:**

- **输入:** s = "IX"
- **输出:** 9

**示例 4:**

- **输入:** s = "LVIII"
- **输出:** 58
- **解释:** L = 50, V= 5, III = 3.

**示例 5:**

- **输入:** s = "MCMXCIV"
- **输出:** 1994
- **解释:** M = 1000, CM = 900, XC = 90, IV = 4.

### 参考代码
```cpp
    int romanToInt(string s)
    {
        // 创建一个哈希表，将罗马数字对应的整数值进行映射
        unordered_map<char, int> map = {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}};
        char preChar = 'I'; // 初始化前一个字符为 'I'
        int sum = 0;        // 用于存储转换后的整数总和
        // 从字符串的最后一个字符开始向前遍历
        for (int i = s.length() - 1; i >= 0; --i)
        {
            // 如果当前字符对应的值小于前一个字符对应的值，则减去当前值
            if (map[s[i]] < map[preChar])
                sum -= map[s[i]];
            else // 否则，加上当前值
                sum += map[s[i]];
            preChar = s[i]; // 更新前一个字符
        }
        return sum; // 返回最终计算出的整数值
    }
```

#### 代码分析

1. **哈希表的使用**：
	- 利用 `unordered_map<char, int>` 创建了一个哈希表，将罗马数字字符（如 'I', 'V', 'X' 等）对应的整数值进行了映射。这使得查找每个罗马字符的整数值变得高效。

2. **初始化变量**：
	- `preChar` 用于记录前一个字符，初始设为 'I'。
	- `sum` 用于累计转换后的总和，初始为 0。

3. **从后向前遍历**：
	- 该算法自字符串的最后一个字符开始向前遍历，这是处理罗马数字的一种常见方法。
	- 遍历过程中比较当前字符与前一个字符对应的值：
		- 若当前字符的值小于前一个字符的值，则表示需减去当前值。
		 - 否则，直接加上当前值。

4. **更新前一个字符**：
	- 在每次循环结束后，更新 `preChar` 为当前字符，以便下次判断。

5. **返回结果**：
	- 最终返回 `sum`，即转换得到的整数值。

#### 注意点

- **字符顺序的重要性**：罗马数字的构成规则决定了从后向前遍历是必要的，这是因为可能会出现小的罗马数字在大的罗马数字前面的情况（如 IV = 4）。
- **边界条件**：应注意输入字符串的合法性，例如只允许包含有效的罗马数字字符。
- **性能考虑**：该实现的时间复杂度为 O(n)，其中 n 是输入字符串的长度；空间复杂度为 O(1)，因映射表不会随输入大小而变化。
- **哈希表的适用性**：使用哈希表可以快速查找罗马字符的值，这是提高效率的重要设计。
---

## 67. 二进制求和

[力扣原题链接 (简单题)](https://leetcode.cn/problems/add-binary/description/)

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

**示例 1：**

- **输入:** a = "11", b = "1"
- **输出：** "100"

**示例 2：**

- **输入：** a = "1010", b = "1011"
- **输出：** "10101"

### 参考代码

```cpp
    string addBinary(string a, string b)
    {
        vector<int> numA, numB, res; // 用于存储二进制数字和结果的向量
        // 将二进制字符串 a 转换为数字向量 numA
        for (const auto &nA : a)
        {
            if (nA == '1')
                numA.push_back(1); // 如果是 '1'，则添加 1
            else
                numA.push_back(0); // 否则添加 0
        }
        // 将二进制字符串 b 转换为数字向量 numB
        for (const auto &nB : b)
        {
            if (nB == '1')
                numB.push_back(1); // 如果是 '1'，则添加 1
            else
                numB.push_back(0); // 否则添加 0
        }
        int k = 0, sum = 0; // k 用于记录进位，sum 用于计算和
        // 当 numA 和 numB 都不为空时进行加法运算
        while (!numA.empty() && !numB.empty())
        {
            sum = k + numA.back() + numB.back(); // 计算当前位的和
            k = 0;                               // 初始化进位
            if (sum / 2 > 0)                     // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numA.pop_back();        // 移除处理过的数字
            numB.pop_back();        // 移除处理过的数字
        }
        // 处理 numA 还剩余的部分
        while (!numA.empty())
        {
            sum = k + numA.back(); // 计算当前位的和
            k = 0;                 // 初始化进位
            if (sum / 2 > 0)       // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numA.pop_back();        // 移除处理过的数字
        }
        // 如果 numB 为空且还有进位，则添加 1
        if (numB.empty() && k > 0)
        {
            res.push_back(1);
            k = 0; // 清除进位
        }
        // 处理 numB 还剩余的部分
        while (!numB.empty())
        {
            sum = k + numB.back(); // 计算当前位的和
            k = 0;                 // 初始化进位
            if (sum / 2 > 0)       // 判断是否需要进位
            {
                k = 1;                  // 进位为 1
                res.push_back(sum % 2); // 当前位结果
            }
            else
                res.push_back(sum); // 当前位结果为 sum
            numB.pop_back();        // 移除处理过的数字
        }
        // 如果还有进位，添加 1
        if (k > 0)
            res.push_back(1);
        // 将结果向量转换为字符串
        string s(res.size(), '0');
        for (size_t i = 0; i < res.size(); ++i)
        {
            s[i] = static_cast<char>(res[i] + '0'); // 将数字转换为字符
        }
        // 反转字符串以得到正确的结果
        return string(s.rbegin(), s.rend());
    }
```

#### 主要步骤

1. **字符串转换**：
	- 将二进制字符串 `a` 和 `b` 转换为整数向量 `numA` 和 `numB`。如果字符为 `'1'`，则在向量中添加 `1`，否则添加 `0`。

2. **加法运算**：
	- 使用两个 `while` 循环遍历两个向量，直到至少一个向量为空，逐位对两个二进制位进行加法计算，同时处理进位 `k`。
	- 如果当前位的和大于等于2，则进位 `k` 设为1，否则进位为0。

3. **处理剩余位**：
	- 如果一个向量处理完了，继续处理另一个向量中剩余的位及进位。

4. **构建结果字符串**：
	- 最后，将结果向量 `res` 转换为字符串，注意需要反转字符串以得到正确的二进制表示。

#### 注意点

- **进位处理**：在每次计算时，要注意处理进位，其值可能会影响当前位的和。
- **字符串反转**：结果向量存储的是从最低位开始的计算结果，因此在返回前需要反转字符串顺序。
- **字符转换**：在向结果字符串中插入数字时，通过加 `'0'` 转换整数为字符。
- **边界条件**：需要考虑到一个或者两个输入字符串为空的情况，以防止出现错误。

---

## 434. 字符串中的单词数

[力扣原题链接 (简单题)](https://leetcode.cn/problems/number-of-segments-in-a-string/description/)

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**

- **输入:** "Hello, my name is John"
- **输出:** 5
- **解释:** 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。

### 参考代码

```cpp
    int countSegments(string s)
    {
        // 如果字符串为空，则返回0
        // if (s.empty())
        //     return 0;
        int count = 0; // 单词计数器
        s.push_back(' '); // 在字符串末尾添加空格，以便处理最后一个单词
        // 遍历字符串
        for (size_t i = 0; i < s.length() - 1; ++i)
        {
            // 如果当前字符不是空格且下一个字符是空格，则说明找到了一个单词
            if (!isspace(s[i]) && isspace(s[i + 1]))
                ++count; // 增加单词计数
        }
        return count; // 返回单词总数
    }
```

#### 代码逻辑

1. **特殊情况处理**:
	- 在字符串末尾添加一个空格，以确保最后一个单词能够被正确识别。这是为了避免处理最后一个单词时遗漏。

2. **初始化计数器**:
	- 定义一个变量 `count` 用于记录单词的数量，并初始化为 0。

3. **遍历字符串**:
	- 使用 `for` 循环遍历字符串的每个字符，检查当前字符和下一个字符：
		 - 如果当前字符不是空格且下一个字符是空格，说明找到了一个完整的单词，计数器 `count` 加一。

4. **返回结果**:
	- 循环结束后，返回单词总数。

#### 注意点

- **字符判断**：使用 `isspace` 函数来判断字符是否为空格，确保在统计时只考虑空格。
- **边界情况**：如果字符串为空，虽然在代码中可以处理，但可以提前返回 0 以优化性能（这部分已注释）。